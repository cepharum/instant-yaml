/**
 * (c) 2019 cepharum GmbH, Berlin, http://cepharum.de
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2019 cepharum GmbH
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * @license
 * @author: cepharum
 */
"use strict";const ParserModes={LEADING_SPACE:0,LF:1,NAME:2,QUOTED_NAME:3,ESCAPED_QUOTED_NAME:4,COLON:5,VALUE:6,FOLDED_VALUE:7,QUOTED_VALUE:8,ESCAPED_QUOTED_VALUE:9,COMMENT:10,LINEBREAK:11,GOT_DASH:12},Errors={character:"invalid character",indentation:"invalid indentation",linebreak:"invalid linebreak",comment:"invalid comment",depth:"invalid depth of hierarchy",exists:"replacing existing property of same object",collection:"invalid mix of collections",scalar:"collection expected, but got scalar",folded:"invalid folded value",quote:"missing closing quote",eof:"unexpected end of file"},EmptyObject={},EmptyArray=[];function ParserError(e,r,s){throw new Error(e+" in line "+r+", column "+s)}function escapes(e,r){switch(r){case"n":return"\n";case"t":return"\t";case"f":return"\f";case"v":return"\v";default:return r}}module.exports.YAML={parse:function(e,r){const s=r||[];if("object"==typeof e&&e)return e;if("string"!=typeof e)throw new TypeError("invalid or missing code to be parsed");const a=e.length,t=[{depth:0,selector:null,ref:{}}];let o=ParserModes.LEADING_SPACE,c=null,n=1,l=1,i=0,E=0,d=0;for(let r=0;r<=a;r++,l++){const u=r<a?e[r]:"\n";switch(o){case ParserModes.LEADING_SPACE:switch(u){case" ":case"\t":break;case"\r":o=ParserModes.LF;break;case"\n":i=r+1;break;case"#":o=c&&c.folded?ParserModes.FOLDED_VALUE:ParserModes.COMMENT;break;default:if(d=r-(E=i),c&&c.folded){if(d>c.depth){null==c.value&&(c.foldedIndentation=d-c.depth),i+=c.depth,o=ParserModes.FOLDED_VALUE;break}this.consume(c,t,s),c=null}switch(c={depth:d,line:n,column:l},i=r,u){case"'":case'"':o=ParserModes.QUOTED_NAME;break;case"-":o=ParserModes.GOT_DASH,i=r;break;default:o=ParserModes.NAME,r--,l--}}break;case ParserModes.GOT_DASH:if(/\s/.test(u)){if(c.isArrayItem||c.isProperty){const a=e.substring(i,r);c.value=c.isArrayItem?EmptyArray:EmptyObject,this.consume(c,t,s),c={depth:c.depth+1+a.match(/^\s*/)[0].length,isArrayItem:!0,line:n,column:l}}else c.isArrayItem=!0;switch(u){case"\r":c.value=EmptyObject,this.consume(c,t,s),o=ParserModes.LF;break;case"\n":c.value=EmptyArray,this.consume(c,t,s),o=ParserModes.LEADING_SPACE,i=r+1;break;case" ":case"\t":o=ParserModes.VALUE,i=r+1;break;default:ParserError(Errors.character,n,l)}}else c.isProperty||c.isArrayItem&&/[\d.]/.test(u)?o=ParserModes.VALUE:ParserError(Errors.character,n,l);break;case ParserModes.LF:"\n"!==u&&ParserError(Errors.linebreak,n,l),o=ParserModes.LEADING_SPACE,i=r+1;break;case ParserModes.NAME:switch(u){case":":c.isProperty=!0,c.propertyName=e.substring(i,r).trim(),o=ParserModes.VALUE,i=r+1;break;case" ":case"\t":c.isProperty=!0,c.propertyName=e.substring(i,r).trim(),o=ParserModes.COLON;break;case"\r":case"\n":ParserError(Errors.linebreak,n,l);break;case"#":ParserError(Errors.comment,n,l);break;default:if(/[a-zA-Z0-9_]/.test(u))break;ParserError(Errors.character,n,l)}break;case ParserModes.QUOTED_NAME:switch(u){case"\\":o=ParserModes.ESCAPED_QUOTED_NAME;break;case"\r":case"\n":ParserError(Errors.linebreak,n,l);break;case e[i]:c.isProperty=!0,c.propertyName=e.substring(i+1,r).replace(/\\(.)/g,escapes),o=ParserModes.COLON}break;case ParserModes.ESCAPED_QUOTED_NAME:switch(u){case"\r":case"\n":ParserError(Errors.linebreak,n,l);break;default:o=ParserModes.QUOTED_NAME}break;case ParserModes.COLON:switch(u){case":":o=ParserModes.VALUE,i=r+1;break;case" ":case"\t":break;case"\r":case"\n":ParserError(Errors.linebreak,n,l);break;case"#":ParserError(Errors.comment,n,l);break;default:ParserError(Errors.character,n,l)}break;case ParserModes.VALUE:switch(u){case"#":c.value=e.substring(i,r).trim(),o=ParserModes.COMMENT;break;case"'":case'"':/\S/.test(e.substring(i,r))||(o=ParserModes.QUOTED_VALUE,i=c.quotedValue=r);break;case"\r":c.value=e.substring(i,r).trim(),""===c.value&&(c.value=EmptyObject),o=ParserModes.LF;break;case"\n":c.value=e.substring(i,r).trim(),""===c.value&&(c.value=EmptyObject),o=ParserModes.LEADING_SPACE,i=r+1;break;case":":if(c.isArrayItem||c.isProperty){const a=e.substring(i,r),o=a.trim();/^[a-zA-Z0-9_]+$/.test(o)&&(c.value=EmptyObject,this.consume(c,t,s),c={depth:c.depth+1+a.match(/^\s*/)[0].length,isProperty:!0,propertyName:o,line:n,column:l},i=r+1)}break;case"-":if(c.isArrayItem||c.isProperty){e.substring(i,r).trim().length||(o=ParserModes.GOT_DASH)}}switch(c.value){case">":case">-":case">+":case"|":case"|-":case"|+":c.folded=c.value,c.value=null;break;case null:case void 0:break;case"":c.value=EmptyObject;default:this.consume(c,t,s),c=null}break;case ParserModes.QUOTED_VALUE:switch(u){case"\\":o=ParserModes.ESCAPED_QUOTED_VALUE;break;case"\r":case"\n":ParserError(Errors.linebreak,n,l);break;case e[i]:c.value=e.substring(i+1,r).replace(/\\(.)/g,escapes),o=ParserModes.LINEBREAK,i=r+1}break;case ParserModes.ESCAPED_QUOTED_VALUE:switch(u){case"\r":case"\n":ParserError(Errors.linebreak,n,l);break;default:o=ParserModes.QUOTED_VALUE}break;case ParserModes.FOLDED_VALUE:{let s=!1;switch(u){case"\r":s=!0;case"\n":{const a=e.substr(i,c.foldedIndentation);let t=e.substring(i+c.foldedIndentation,r);const n=/\S/.exec(a);if(n){const e=c.foldedIndentation-n.index;let r="";for(let s=0;s<e;s++)r+=" ";c.value=c.value.replace(/(^|\n[^\n]+)/g,"$1"+r),c.foldedIndentation=n.index,t=a.substr(n.index)+t}c.value=(null==c.value?"":c.value)+t,s?o=ParserModes.LF:(o=ParserModes.LEADING_SPACE,i=r+1);break}}break}case ParserModes.COMMENT:switch(u){case"\r":o=ParserModes.LF;break;case"\n":o=ParserModes.LEADING_SPACE,i=r+1}break;case ParserModes.LINEBREAK:switch(u){case" ":case"\t":break;case"\r":this.consume(c,t,s),c=null,o=ParserModes.LF;break;case"\n":this.consume(c,t,s),c=null,o=ParserModes.LEADING_SPACE,i=r+1;break;case"#":this.consume(c,t,s),c=null,o=ParserModes.COMMENT;break;case":":if(c.isArrayItem&&"string"==typeof c.value){const e=c.value;if(/^[a-zA-Z0-9_]+$/.test(e)){c.value=EmptyObject,this.consume(c,t,s),c={depth:c.startQuote+1+c.value.match(/^\s*/)[0].length,isProperty:!0,propertyName:e,line:n,column:l},o=ParserModes.VALUE,i=r+1;break}}ParserError(Errors.character,n,l);break;default:ParserError(Errors.character,n,l)}}"\n"===u&&r<a&&(c&&c.folded&&null!=c.value&&(c.value+="\n"),n++,l=0)}switch(o){case ParserModes.VALUE:switch(c.value=e.substring(i).trim(),c.value){case"|":case">":ParserError(Errors.folder,n,l);break;case"":c.value=EmptyObject;default:this.consume(c,t,s),c=null}break;case ParserModes.LINEBREAK:this.consume(c,t,s);break;case ParserModes.LEADING_SPACE:c&&c.folded&&this.consume(c,t,s);break;case ParserModes.COMMENT:break;case ParserModes.QUOTED_NAME:case ParserModes.ESCAPED_QUOTED_NAME:case ParserModes.QUOTED_VALUE:case ParserModes.ESCAPED_QUOTED_VALUE:ParserError(Errors.quote,n,l);break;default:ParserError(Errors.eof,n,l)}return t[t.length-1].ref},consume:function(e,r,s){const a=e.depth;for(;;){const s=r[0];if(!s)return void ParserError(Errors.depth,e.line,e.column);const t=s.depth;if(isNaN(t)&&(r[1]||{}).depth<a){s.depth=a;break}if(t===a)break;t<a&&ParserError(Errors.indentation,e.line,e.column),r.shift()}switch(e.value){case EmptyArray:case EmptyObject:{let a=r[0].ref,t=Array.isArray(a);e.isArrayItem&&!t&&0===Object.keys(a).length&&(a=r[0].ref=[],t=!0,r.length>1&&(r[1].ref[r[0].selector]=a));const o=t?a.length:e.propertyName,c=e.value===EmptyArray?[]:{};return r.unshift({depth:NaN,selector:o,ref:c}),t?a.push(c):a[e.propertyName]=c,void s.push(e)}}let t=r[0].ref;if(e.isArrayItem^Array.isArray(t)){if(Object.keys(t).length>0)return void ParserError(Errors.collection,e.line,e.column);const s=r[0].selector;t=e.isArrayItem?r[0].ref=[]:r[0].ref={},null!=s&&r.length>1&&(r[1].ref[s]=t)}switch(e.value){case EmptyObject:case EmptyArray:ParserError(Errors.indentation,e.line,e.column);break;default:if(e.folded){const r=/^([|>])([+-])?$/.exec(e.folded);e.value=e.value.replace(/(\n\s*$)|(?:\n([^ \t]))/g,function(e,s,a){if(s)switch(r[2]){case"+":return s;case"-":return"";default:return"\n"}return(">"===r[1]?"\n"===a?"":" ":"\n")+a})}else if(!e.quotedValue){const r=e.value.trim();"null"===r?e.value=null:/^(?:y(?:es)?|true|on)$/i.test(r)?e.value=!0:/^(?:no?|false|off)$/i.test(r)?e.value=!1:r.replace(/^[+-]/,"").length>0&&/^(?:[+-])?(?:\d+)?(?:\.\d+)?$/i.test(r)?e.value=parseFloat(r):e.value=r}}e.isArrayItem?t.push(e.value):e.isProperty?t[e.propertyName]=e.value:ParserError(Errors.scalar,e.line,e.column),s.push(e)}};